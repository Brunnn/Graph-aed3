{"version":3,"sources":["webpack://btree-project/./src/graph/GraphDirection.ts","webpack://btree-project/./src/graph/graph.ts","webpack://btree-project/./src/main.ts","webpack://btree-project/webpack/bootstrap","webpack://btree-project/webpack/startup"],"names":["require","exports","GraphDirection","Object","defineProperty","value","GraphDirection_1","Graph","direction","this","_adjacencyList","_direction","prototype","addVertex","vertex","addEdge","source","destination","wheight","i","length","splice","push","getGraphDirection","NotDirectioned","removeEdge","edgeWheight","filter","edge","removeVertex","adjacentVertex","pop","dijkstra","startVertex","tempAdjacencyList","getAdjacencyList","visited","Array","unvisited","keys","shortestPathTable","forEach","item","shortestFromStart","Infinity","previousVertex","currentVertex","lastCheckedWheight","key","indexOf","_i","_a","vertexEdge","edgeTotalDistance","parseInt","shortestPath","nodeSequence","prev","console","log","total","default","graph_1","window","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","module","__webpack_modules__"],"mappings":"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","file":"bundle.js","sourcesContent":["define([\"require\", \"exports\"], function (require, exports) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.GraphDirection = void 0;\r\n    var GraphDirection;\r\n    (function (GraphDirection) {\r\n        GraphDirection[GraphDirection[\"Directioned\"] = 1] = \"Directioned\";\r\n        GraphDirection[GraphDirection[\"NotDirectioned\"] = 2] = \"NotDirectioned\";\r\n    })(GraphDirection = exports.GraphDirection || (exports.GraphDirection = {}));\r\n});\r\n","define([\"require\", \"exports\", \"./GraphDirection\"], function (require, exports, GraphDirection_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    var Graph = /** @class */ (function () {\r\n        function Graph(direction) {\r\n            this._adjacencyList = {};\r\n            this._direction = direction;\r\n        }\r\n        Graph.prototype.addVertex = function (vertex) {\r\n            if (!this._adjacencyList[vertex])\r\n                this._adjacencyList[vertex] = [];\r\n            return this;\r\n        };\r\n        Graph.prototype.addEdge = function (source, destination, wheight) {\r\n            if (!this._adjacencyList[source])\r\n                this.addVertex(source);\r\n            if (!this._adjacencyList[destination])\r\n                this.addVertex(destination);\r\n            for (var i = 0; i < this._adjacencyList[source].length; i++) {\r\n                if (this._adjacencyList[source][i].destination == destination) {\r\n                    this._adjacencyList[source].splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n            //Adicionar ligação entre dois nós\r\n            this._adjacencyList[source].push({ destination: destination, wheight: wheight });\r\n            //Se o grafo é nao direcionado ele adicionar ao contrario\r\n            if (this.getGraphDirection() == GraphDirection_1.GraphDirection.NotDirectioned)\r\n                this._adjacencyList[destination].push({ destination: source, wheight: wheight });\r\n            return this;\r\n        };\r\n        Graph.prototype.removeEdge = function (source, destination, edgeWheight) {\r\n            this._adjacencyList[source] = this._adjacencyList[source].filter(function (edge) { return edge.destination !== destination && edge.wheight !== edgeWheight; });\r\n            if (this.getGraphDirection() == GraphDirection_1.GraphDirection.NotDirectioned)\r\n                this._adjacencyList[destination] = this._adjacencyList[destination].filter(function (edge) { return edge.destination !== destination && edge.wheight !== edgeWheight; });\r\n            return this;\r\n        };\r\n        Graph.prototype.removeVertex = function (vertex) {\r\n            while (this._adjacencyList[vertex].length > 0) {\r\n                var adjacentVertex = this._adjacencyList[vertex].pop();\r\n                this.removeEdge(vertex, adjacentVertex.destination, adjacentVertex.wheight);\r\n            }\r\n            delete this._adjacencyList[vertex];\r\n            return this;\r\n        };\r\n        /* \t\tMenor caminho para desde A | Ultimo no visitado\r\n            A | \t\t0                 |  x\r\n            B |         x\t\t\t\t   |  x\r\n            C |         x\t\t\t\t   |  x\r\n        \r\n        \r\n        \r\n        */\r\n        Graph.prototype.dijkstra = function (startVertex, destination) {\r\n            var tempAdjacencyList = this.getAdjacencyList();\r\n            var visited = new Array();\r\n            var unvisited = Object.keys(tempAdjacencyList);\r\n            //Tabela de nós passados\r\n            var shortestPathTable = {};\r\n            unvisited.forEach(function (item) {\r\n                shortestPathTable[item] = { shortestFromStart: Infinity, previousVertex: null };\r\n            });\r\n            shortestPathTable[startVertex].shortestFromStart = 0;\r\n            var currentVertex = startVertex;\r\n            while (true) {\r\n                if (unvisited.length == 0)\r\n                    break;\r\n                //Seleciona na tabela o vértice com menor distancia.\r\n                var lastCheckedWheight = Infinity;\r\n                Object.keys(shortestPathTable).forEach(function (key) {\r\n                    if (visited.indexOf(key) == -1 && shortestPathTable[key].shortestFromStart <= lastCheckedWheight) {\r\n                        lastCheckedWheight = shortestPathTable[key].shortestFromStart;\r\n                        currentVertex = key;\r\n                    }\r\n                });\r\n                //Percorre os vizinhos do vértice atual\r\n                for (var _i = 0, _a = tempAdjacencyList[currentVertex]; _i < _a.length; _i++) {\r\n                    var vertexEdge = _a[_i];\r\n                    if (visited.indexOf(vertexEdge.destination) != -1)\r\n                        continue;\r\n                    //@ts-ignore\r\n                    var edgeTotalDistance = parseInt(shortestPathTable[currentVertex].shortestFromStart) + parseInt(vertexEdge.wheight);\r\n                    if (shortestPathTable[vertexEdge.destination].shortestFromStart > edgeTotalDistance) {\r\n                        shortestPathTable[vertexEdge.destination].previousVertex = currentVertex;\r\n                        shortestPathTable[vertexEdge.destination].shortestFromStart = edgeTotalDistance;\r\n                    }\r\n                }\r\n                unvisited.splice(unvisited.indexOf(currentVertex), 1);\r\n                visited.push(currentVertex);\r\n            }\r\n            //Monta o trajeto do caminho mais curto\r\n            var shortestPath = shortestPathTable[destination].shortestFromStart;\r\n            var nodeSequence = [];\r\n            var prev = destination;\r\n            while (shortestPath != Infinity) {\r\n                if (prev == startVertex) {\r\n                    nodeSequence.push(prev);\r\n                    break;\r\n                }\r\n                nodeSequence.push(prev);\r\n                prev = shortestPathTable[prev].previousVertex;\r\n            }\r\n            console.log({ total: shortestPath, nodeSequence: nodeSequence });\r\n            return { total: shortestPath, nodeSequence: nodeSequence };\r\n        };\r\n        ;\r\n        Graph.prototype.getGraphDirection = function () {\r\n            return this._direction;\r\n        };\r\n        Graph.prototype.getAdjacencyList = function () {\r\n            return this._adjacencyList;\r\n        };\r\n        return Graph;\r\n    }());\r\n    exports.default = Graph;\r\n});\r\n","define([\"require\", \"exports\", \"./graph/graph\"], function (require, exports, graph_1) {\r\n    \"use strict\";\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    //@ts-ignore\r\n    window.Graph = graph_1.default;\r\n});\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(519);\n"],"sourceRoot":""}